{"ast":null,"code":"// qui andremo a scrivere la nostra funzione Reducer\n// la funzione reducer serve a calcolare il nuovo stato dell'app ogni volta che una action viene \"dispatchata\"\n// il reducer è in grado di calcolare il nuovo stato grazie ai due parametri con i quali viene invocato: lo stato attuale dell'app (\"state\") e la più recente action \"dispatchata\" (action)\n\n// l'unica cosa che ci manca a questo punto è lo STATO INIZIALE di Redux\n// al momento ci interessa salvare il contenuto del carrello dei libri!\n\nconst initialState = {\n  // dividiamo per ragioni organizzative lo state in SLICES (fette)\n  cart: {\n    content: [] // all'inizio non abbiamo libri nel carrello\n    // ready: true,\n  }\n  //   user: {\n  //     blabla: true,\n  //   },\n  // immaginiamo di avere uno stato complesso\n};\n\n// alla prima invocazione di mainReducer (che avviene al caricamento della pagina) state è undefined (non esiste ancora!); diamo come valore di default del parametro state il nostro oggetto \"initialState\"\nconst mainReducer = (state = initialState, action) => {\n  // mainReducer calcolerà lo stato nuovo\n  // quindi ritornerà SEMPRE un oggetto, il nuovo stato dell'app\n\n  // mainReducer è una PURE FUNCTION, non può modificare i propri parametri e non può eseguire \"side-effects\" (ad es. contattare delle API)\n\n  switch (action.type) {\n    // qui inseriamo tutte le possibili casistiche\n    case 'ADD_TO_CART':\n      // qui dentro fornisco istruzioni al mio reducer su COSA FARE\n      // quando intercetta una action con type \"ADD_TO_CART\"\n      return {\n        // devo SEMPRE ritornare un oggetto, il nuovo stato dell'app\n        ...state,\n        // andiamo a riscrivere la slice di nostro interesse\n        cart: {\n          ...state.cart,\n          //   vado a ri-dichiarare \"content\" prestando attenzione a NON utilizzare metodi e tecniche che andrebbero ad alterare il valore di state, perchè in una funzione pura non si possono mutare i propri parametri\n          content: state.cart.content.concat(action.payload)\n          // NON POTETE USARE PUSH (perchè modifica l'array di partenza e di fatto ROMPE la funzione pura!)\n          //   content: [...state.cart.content, action.payload]\n        }\n      };\n    case 'REMOVE_FROM_CART':\n      return {\n        ...state,\n        cart: {\n          ...state.cart,\n          content: state.cart.content.filter((book, i) => {\n            if (i === action.payload) {\n              return false;\n            } else {\n              return true;\n            }\n          })\n          // PRO VERSION\n          //   content: state.cart.content.filter((_, i) => i !== action.payload),\n          // METODO ALTERNATIVO CON SLICE\n          //   content: [\n          //     ...state.cart.content.slice(0, action.payload),\n          //     ...state.cart.content.slice(action.payload + 1),\n          //   ],\n        }\n      };\n    default:\n      // finiamo qui dentro se l'action.type non corrisponde a nessuno dei case stabiliti precedentemente\n      return state;\n    // nel peggiore dei casi ritorniamo lo stato esattamente come l'abbiamo trovato\n  }\n};\nexport default mainReducer;","map":{"version":3,"names":["initialState","cart","content","mainReducer","state","action","type","concat","payload","filter","book","i"],"sources":["C:/Users/user/Documents/Corso Epicode/Unità 3/W3/D2/notes/src/redux/reducers/index.js"],"sourcesContent":["// qui andremo a scrivere la nostra funzione Reducer\n// la funzione reducer serve a calcolare il nuovo stato dell'app ogni volta che una action viene \"dispatchata\"\n// il reducer è in grado di calcolare il nuovo stato grazie ai due parametri con i quali viene invocato: lo stato attuale dell'app (\"state\") e la più recente action \"dispatchata\" (action)\n\n// l'unica cosa che ci manca a questo punto è lo STATO INIZIALE di Redux\n// al momento ci interessa salvare il contenuto del carrello dei libri!\n\nconst initialState = {\n  // dividiamo per ragioni organizzative lo state in SLICES (fette)\n  cart: {\n    content: [], // all'inizio non abbiamo libri nel carrello\n    // ready: true,\n  },\n  //   user: {\n  //     blabla: true,\n  //   },\n  // immaginiamo di avere uno stato complesso\n}\n\n// alla prima invocazione di mainReducer (che avviene al caricamento della pagina) state è undefined (non esiste ancora!); diamo come valore di default del parametro state il nostro oggetto \"initialState\"\nconst mainReducer = (state = initialState, action) => {\n  // mainReducer calcolerà lo stato nuovo\n  // quindi ritornerà SEMPRE un oggetto, il nuovo stato dell'app\n\n  // mainReducer è una PURE FUNCTION, non può modificare i propri parametri e non può eseguire \"side-effects\" (ad es. contattare delle API)\n\n  switch (action.type) {\n    // qui inseriamo tutte le possibili casistiche\n    case 'ADD_TO_CART':\n      // qui dentro fornisco istruzioni al mio reducer su COSA FARE\n      // quando intercetta una action con type \"ADD_TO_CART\"\n      return {\n        // devo SEMPRE ritornare un oggetto, il nuovo stato dell'app\n        ...state,\n        // andiamo a riscrivere la slice di nostro interesse\n        cart: {\n          ...state.cart,\n          //   vado a ri-dichiarare \"content\" prestando attenzione a NON utilizzare metodi e tecniche che andrebbero ad alterare il valore di state, perchè in una funzione pura non si possono mutare i propri parametri\n          content: state.cart.content.concat(action.payload),\n          // NON POTETE USARE PUSH (perchè modifica l'array di partenza e di fatto ROMPE la funzione pura!)\n          //   content: [...state.cart.content, action.payload]\n        },\n      }\n\n    case 'REMOVE_FROM_CART':\n      return {\n        ...state,\n        cart: {\n          ...state.cart,\n          content: state.cart.content.filter((book, i) => {\n            if (i === action.payload) {\n              return false\n            } else {\n              return true\n            }\n          }),\n          // PRO VERSION\n          //   content: state.cart.content.filter((_, i) => i !== action.payload),\n          // METODO ALTERNATIVO CON SLICE\n          //   content: [\n          //     ...state.cart.content.slice(0, action.payload),\n          //     ...state.cart.content.slice(action.payload + 1),\n          //   ],\n        },\n      }\n\n    default:\n      // finiamo qui dentro se l'action.type non corrisponde a nessuno dei case stabiliti precedentemente\n      return state\n    // nel peggiore dei casi ritorniamo lo stato esattamente come l'abbiamo trovato\n  }\n}\n\nexport default mainReducer\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;;AAEA,MAAMA,YAAY,GAAG;EACnB;EACAC,IAAI,EAAE;IACJC,OAAO,EAAE,EAAE,CAAE;IACb;EACF;EACA;EACA;EACA;EACA;AACF,CAAC;;AAED;AACA,MAAMC,WAAW,GAAGA,CAACC,KAAK,GAAGJ,YAAY,EAAEK,MAAM,KAAK;EACpD;EACA;;EAEA;;EAEA,QAAQA,MAAM,CAACC,IAAI;IACjB;IACA,KAAK,aAAa;MAChB;MACA;MACA,OAAO;QACL;QACA,GAAGF,KAAK;QACR;QACAH,IAAI,EAAE;UACJ,GAAGG,KAAK,CAACH,IAAI;UACb;UACAC,OAAO,EAAEE,KAAK,CAACH,IAAI,CAACC,OAAO,CAACK,MAAM,CAACF,MAAM,CAACG,OAAO;UACjD;UACA;QACF;MACF,CAAC;IAEH,KAAK,kBAAkB;MACrB,OAAO;QACL,GAAGJ,KAAK;QACRH,IAAI,EAAE;UACJ,GAAGG,KAAK,CAACH,IAAI;UACbC,OAAO,EAAEE,KAAK,CAACH,IAAI,CAACC,OAAO,CAACO,MAAM,CAAC,CAACC,IAAI,EAAEC,CAAC,KAAK;YAC9C,IAAIA,CAAC,KAAKN,MAAM,CAACG,OAAO,EAAE;cACxB,OAAO,KAAK;YACd,CAAC,MAAM;cACL,OAAO,IAAI;YACb;UACF,CAAC;UACD;UACA;UACA;UACA;UACA;UACA;UACA;QACF;MACF,CAAC;IAEH;MACE;MACA,OAAOJ,KAAK;IACd;EACF;AACF,CAAC;AAED,eAAeD,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}